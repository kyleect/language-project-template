//! Parser and associated types

use crate::errors::{ExprErrorS, SyntaxError};
use crate::ast;
use crate::lexer::Token;
use crate::span::Spanned;

grammar<'err>(source: &str, errors: &'err mut Vec<ExprErrorS>);

pub Expr: ast::Expr = {
    Factor2,
    <e:!> => {
        errors.push(SyntaxError::from_parser_error(e.error, source));
        ast::Expr::new(ast::ExprKind::Error, 0..0)
    }
};

Factor2: ast::Expr = {
    <l:Expr> "+" <r:Factor> => ast::Expr::new(ast::ExprKind::InfixOp(Box::new(ast::ExprInfixOp {
        lt: l.clone().into(),
        op: ast::OpInfix::Add,
        rt: r.clone().into()
    })), l.span().start..r.span().start),
    <l:Expr> "-" <r:Factor> => ast::Expr::new(ast::ExprKind::InfixOp(Box::new(ast::ExprInfixOp {
        lt: l.clone().into(),
        op: ast::OpInfix::Subtract,
        rt: r.clone().into()
    })), l.span().start..r.span().start),
    Factor,
};


Factor: ast::Expr = {
    <l:Factor> "*" <r:Term> => ast::Expr::new(ast::ExprKind::InfixOp(Box::new(ast::ExprInfixOp {
        lt: l.clone().into(),
        op: ast::OpInfix::Multiply,
        rt: r.clone().into()
    })), l.span().start..r.span().start),
    <l:Factor> "/" <r:Term> => ast::Expr::new(ast::ExprKind::InfixOp(Box::new(ast::ExprInfixOp {
        lt: l.clone().into(),
        op: ast::OpInfix::Divide,
        rt: r.clone().into()
    })), l.span().start..r.span().start),
    Term,
};

Term: ast::Expr = {
    ExprLiteral,
    "(" <Expr> ")",
};

ExprLiteral: ast::Expr = {
    <n:Spanned<number>> => ast::Expr::new(ast::ExprKind::Literal(Box::new(ast::ExprLiteral::Number(n.0))), n.1.clone())
};

// Utility Types

Spanned<T>: Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

extern {
    type Location = usize;
    type Error = ExprErrorS;

    enum Token {
        "(" => Token::LParan,
        ")" => Token::RParan,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "*" => Token::Astrisk,
        number => Token::Number(<f64>),
    }
}