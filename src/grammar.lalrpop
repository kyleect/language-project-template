//! Parser and associated types

use crate::errors::{ExprErrorS, SyntaxError};
use crate::ast;
use crate::lexer::Token;
use crate::span::Spanned;

grammar<'err>(
    source: &str,
    errors: &'err mut Vec<ExprErrorS>
);

pub Expr: ast::Expr = {
    Term,
    <e:!> => {
        // Error recovery during parsing

        errors.push(SyntaxError::from_parser_error(e.error, source));
        ast::Expr::error()
    }
};

Term: ast::Expr = {
    <l:Expr> "+" <r:Factor> => {
        let span = l.start()..r.end();

        ast::Expr::new(
            ast::ExprKind::infix_op(
                l.clone(),
                ast::OpInfix::Add,
                r.clone()
            ),
            span
        )
    },
    <l:Expr> "-" <r:Factor> => {
        let span = l.start()..r.end();

        ast::Expr::new(
            ast::ExprKind::infix_op(
                l.clone(),
                ast::OpInfix::Subtract,
                r.clone()
            ),
            span
        )
    },
    Factor,
};

Factor: ast::Expr = {
    <l:Factor> "*" <r:Literal> => {
        let span = l.start()..r.end();

        ast::Expr::new(
            ast::ExprKind::infix_op(
                l.clone(),
                ast::OpInfix::Multiply,
                r.clone()
            ),
            span
        )
    },
    <l:Factor> "/" <r:Literal> => {
        let span = l.start()..r.end();

        ast::Expr::new(
            ast::ExprKind::infix_op(
                l.clone(),
                ast::OpInfix::Divide,
                r.clone()
            ),
            span
        )
    },
    Literal,
};

Literal: ast::Expr = {
    <n:Spanned<number>> => {
        let (value, span) = n;
        ast::Expr::new(value.into(), span)
    },
    "(" <Expr> ")",
};

// Utility Types

Spanned<T>: Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

extern {
    type Location = usize;
    type Error = ExprErrorS;

    enum Token {
        "(" => Token::LParan,
        ")" => Token::RParan,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "*" => Token::Astrisk,
        number => Token::Number(<f64>),
    }
}